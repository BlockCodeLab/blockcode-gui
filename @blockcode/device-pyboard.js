import{Serial as S,sleep as z} from"@blockcode/core";var Z=function(w){return w.replaceAll("\r\n","\n")},A=function(w){return w.slice(2,-3)},y="\x01",N="\x02",I="\x03",E="\x04";var H=128;class M{constructor(){this.serial=null,this._connected=!1,this._encoder=new TextEncoder,this._decoder=new TextDecoder}requestPort(w=[]){return navigator.serial.requestPort({filters:w}).then(($)=>{if($._serial){this.serial=$._serial,this.serial.on("connect",()=>this._connected=!0),this.serial.on("disconnect",()=>this._connected=!1);return}this.serial=new S($),this.serial.on("connect",()=>this._connected=!0),this.serial.on("disconnect",()=>this._connected=!1)})}connect(w={}){return new Promise(($,q)=>{if(this.serial)this.serial.open({baudRate:115200,...w}).then(()=>$()).catch((G)=>{if(G.name==="InvalidStateError")this._connected=!0,$();q(G)});else q(new Error("No device specified"))})}get connected(){return this._connected}disconnect(){return this.serial.close()}get deviceInfo(){return this.serial.getInfo()}readUntil(w,$){return new Promise((q)=>{let G="";const J=async(Q)=>{if(Q){if(G+=this._decoder.decode(Q),$)$(Q)}if(G.indexOf(w)!==-1)this.serial.off("data",J),q(G)};this.serial.on("data",J)})}writeAndReadUntil(w,$,q){return new Promise(async(G)=>{if($)this.readUntil($,q).then(G);for(let J=0;J<w.length;J+=H)await this.serial.write(w.slice(J,J+H)),await z(10);if(!$)G()})}async getPrompt(){return await z(150),await this.stop(),await z(150),await this.writeAndReadUntil(`\r${I}${N}`,"\r\n>>>")}async enterRawRepl(){return await this.writeAndReadUntil(y,"raw REPL; CTRL-B to exit")}async exitRawRepl(){return await this.writeAndReadUntil(N,"\r\n>>>")}async execRaw(w,$){return await this.writeAndReadUntil(w),await this.writeAndReadUntil(E,`${E}>`,$)}async execFile(w,$){if($=$||function(){},w){await this.enterRawRepl();const q=await this.execRaw(w,$);return await this.exitRawRepl(),q}return Promise.reject()}async run(w,$){return $=$||function(){},new Promise(async(q,G)=>{if(this.rejectRun)this.rejectRun(new Error("re-run")),this.rejectRun=null;this.rejectRun=G;try{await this.enterRawRepl();const J=await this.execRaw(w||"#",$);return await this.exitRawRepl(),q(J)}catch(J){G(J),this.rejectRun=null}})}async eval(w){await this.serial.write(w)}async stop(){if(this.rejectRun)this.rejectRun(new Error("pre stop")),this.rejectRun=null;await this.serial.write(I)}async reset(){if(this.rejectRun)this.rejectRun(new Error("pre reset")),this.rejectRun=null;await this.serial.write(I),await this.serial.write(E)}async exists(w){w=w||"";let $="";$+="try:\n",$+=`  f = open('${w}', 'r')\n`,$+="  print(1)\n",$+="except OSError:\n",$+="  print(0)\n",await this.enterRawRepl();const q=await this.execRaw($);return await this.exitRawRepl(),q[2]=="1"}async listdir(w){w=w||"";let $="";$+="import os\n",$+="try:\n",$+=`  print(os.listdir('${w}'))\n`,$+="except OSError:\n",$+="  print([])\n",await this.enterRawRepl();let q=await this.execRaw($);return await this.exitRawRepl(),q=A(q),q=q.replace(/'/g,'"'),JSON.parse(q)}async mkdir(w){if(w){await this.enterRawRepl();const $=await this.execRaw(`import os\nos.mkdir('${w}')`);return await this.exitRawRepl(),$}return Promise.reject(new Error("Path to file was not specified"))}async rmdir(w){if(w){let $="";$+="import os\n",$+="try:\n",$+=`  os.rmdir("${w}")\n`,$+="except OSError:\n",$+="  print(0)\n",await this.enterRawRepl();const q=await this.execRaw($);return await this.exitRawRepl(),q}return Promise.reject(new Error("Path to file was not specified"))}async remove(w){if(w){let $="";$+="import os\n",$+="try:\n",$+=`  os.remove("${w}")\n`,$+="except OSError:\n",$+="  print(0)\n",await this.enterRawRepl();const q=await this.execRaw($);return this.exitRawRepl(),q}return Promise.reject(new Error("Path to file was not specified"))}async rename(w,$){if(w&&$){await this.enterRawRepl();const q=await this.execRaw(`import os\nos.rename('${w}', '${$}')`);return this.exitRawRepl(),q}return Promise.reject(new Error("Path to file was not specified"))}async cat(w){if(w){await this.enterRawRepl();let $=await this.execRaw(`with open('${w}','r') as f:\n while 1:\n  b=f.read(256)\n  if not b:break\n  print(b,end='')`);return await this.exitRawRepl(),$=A($),Z($)}return Promise.reject(new Error("Path to file was not specified"))}async checkHash(w,$){if(w){let q="";q+="import os\n",q+="import hashlib\n",q+="import binascii\n",q+="hash = hashlib.sha256()\n",q+=`with open('${w}', 'rb') as f:\n`,q+="  while True:\n",q+=`    c = f.read(${H})\n`,q+="    if not c: break\n",q+="    hash.update(c)\n",q+="print(binascii.hexlify(hash.digest()).decode())\n",await this.enterRawRepl();let G=await this.execRaw(q);return await this.exitRawRepl(),G=G.slice(2,G.indexOf("\n")-1),$===G}return Promise.reject(new Error("Path to file was not specified"))}async put(w,$,q){if(!$){Promise.reject(new Error("Must specify content and destination path"));return}let G;if(typeof w==="string")G=this._encoder.encode(Z(w));else if(w instanceof ArrayBuffer)G=new Uint8Array(w);else if(w instanceof Uint8Array)G=w;else Promise.reject(new Error(`${w} must string, Uint8Array or ArrayBuffer`));if(q=q||function(){},await this.exists($)){const O=await crypto.subtle.digest("SHA-256",G),V=Array.from(new Uint8Array(O)).map((Y)=>Y.toString(16).padStart(2,"0")).join("");if(await this.checkHash($,V)){q(100);return}}const J=Array.from(G).map((O)=>O.toString(16).padStart(2,"0"));let Q="";Q+=await this.enterRawRepl();let W=$.split("/");if(W.pop(),W.length>0){Q+=await this.execRaw("import os");const O=[];W.reduce((V,Y)=>{if(Y===""||V!==""&&V.at(-1)!=="/")V+="/";if(V+=Y,V!=="/")O.push(V);return V},"");for(let V of O)Q+=await this.execRaw(`os.mkdir('${V}')`)}Q+=await this.execRaw(`f=open('${$}','w')\nw=f.write`);const X=48;for(let O=0;O<J.length;O+=X){let R=`w(bytes([${J.slice(O,O+X).map((B)=>`0x${B}`).join(",")}]))`;Q+=await this.execRaw(R),q(parseInt(O/J.length*100))}return Q+=await this.execRaw("f.close()"),Q+=await this.exitRawRepl(),q(100),Q}}function K(w,$){const q=`data:${w};base64,${$}`;return fetch(q).then((G)=>G.arrayBuffer())}var g=async(w,$)=>{const q=new M;await q.requestPort(w),await q.connect(),await q.stop(),$(q);const G=()=>setTimeout(async()=>{if(q.connected)G();else $(null)},1000);return G(),q},x=async(w,$)=>{await w.disconnect(),$(null)},D=async(w,$)=>{await w.stop(),await w.enterRawRepl(),await w.execRaw(`from ${$} import display`),await w.execRaw("display.fill(0x0000)"),await w.execRaw("cx, cy = display.width // 2, display.height // 2"),await w.execRaw("display.ellipse(cx, cy, 60, 60, 0xffff, True)"),await w.execRaw("display.ellipse(cx, cy, 50, 50, 0x0000, True)"),await w.execRaw("display.linex(cx, cy - 30, cx, cy + 30, 10, 0xffff)"),await w.execRaw("display.linex(cx, cy + 30, cx + 15, cy + 15, 10, 0xffff)"),await w.execRaw("display.linex(cx, cy + 30, cx - 15, cy + 15, 10, 0xffff)"),await w.execRaw("display.render()"),await w.exitRawRepl()},L=async(w,$,q)=>{await w.stop();const G=$.length;let J=0;const Q=(W)=>{q(parseInt((J+1/G*(W/100))*100))};for(let W of $){let{id:X,content:O}=W;if(W.type==="text/x-python")X+=".py";else if(W.type.startsWith("image/")&&!O)O=await K(W.type,W.data);await w.put(O||"",X,Q),J+=1/G}q(100),await w.reset()};export{D as showDownloadScreen,L as downloadDevice,x as disconnectDevice,g as connectDevice,M as MicroPythonBoard};
