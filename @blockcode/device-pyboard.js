import{Serial as B,sleep as I} from"@blockcode/core";var U=function(G){return G.replaceAll("\r\n","\n")},S=function(G){return G.slice(2,-3)},j="\x01",Z="\x02",M="\x03",z="\x04";var A=128;class ${constructor(){this.serial=null,this._connected=!1,this._encoder=new TextEncoder,this._decoder=new TextDecoder}requestPort(G=[]){return navigator.serial.requestPort({filters:G}).then((q)=>{this.serial=new B(q),this.serial.on("connect",()=>this._connected=!0),this.serial.on("disconnect",()=>this._connected=!1)})}connect(G={}){return new Promise((q,J)=>{if(this.serial)this.serial.open({baudRate:115200,...G}).then(q).catch(J);else J(new Error("No device specified"))})}get connected(){return this._connected}disconnect(){return this.serial.close()}get deviceInfo(){return this.serial.getInfo()}readUntil(G,q){return new Promise((J)=>{let O="";const Q=async(V)=>{if(V){if(O+=this._decoder.decode(V),q)q(V)}if(O.indexOf(G)!==-1)this.serial.off("data",Q),J(O)};this.serial.on("data",Q)})}writeAndReadUntil(G,q,J){return new Promise(async(O)=>{if(q)this.readUntil(q,J).then(O);for(let Q=0;Q<G.length;Q+=A)await this.serial.write(G.slice(Q,Q+A)),await I(10);if(!q)O()})}async getPrompt(){return await I(150),await this.stop(),await I(150),await this.writeAndReadUntil(`\r${M}${Z}`,"\r\n>>>")}async enterRawRepl(){return await this.writeAndReadUntil(j,"raw REPL; CTRL-B to exit")}async exitRawRepl(){return await this.writeAndReadUntil(Z,"\r\n>>>")}async execRaw(G,q){return await this.writeAndReadUntil(G),await this.writeAndReadUntil(z,`${z}>`,q)}async execFile(G,q){if(q=q||function(){},G){await this.enterRawRepl();const J=await this.execRaw(G,q);return await this.exitRawRepl(),J}return Promise.reject()}async run(G,q){return q=q||function(){},new Promise(async(J,O)=>{if(this.rejectRun)this.rejectRun(new Error("re-run")),this.rejectRun=null;this.rejectRun=O;try{await this.enterRawRepl();const Q=await this.execRaw(G||"#",q);return await this.exitRawRepl(),J(Q)}catch(Q){O(Q),this.rejectRun=null}})}async eval(G){await this.serial.write(G)}async stop(){if(this.rejectRun)this.rejectRun(new Error("pre stop")),this.rejectRun=null;await this.serial.write(M)}async reset(){if(this.rejectRun)this.rejectRun(new Error("pre reset")),this.rejectRun=null;await this.serial.write(M),await this.serial.write(z)}async exists(G){G=G||"";let q="";q+="try:\n",q+=`  f = open('${G}', 'r')\n`,q+="  print(1)\n",q+="except OSError:\n",q+="  print(0)\n",await this.enterRawRepl();let J=await this.execRaw(q);return await this.exitRawRepl(),J[2]=="1"}async listdir(G){G=G||"";let q="";q+="import os\n",q+="try:\n",q+=`  print(os.listdir('${G}'))\n`,q+="except OSError:\n",q+="  print([])\n",await this.enterRawRepl();let J=await this.execRaw(q);return await this.exitRawRepl(),J=S(J),J=J.replace(/'/g,'"'),JSON.parse(J)}async mkdir(G){if(G){await this.enterRawRepl();const q=await this.execRaw(`import os\nos.mkdir('${G}')`);return await this.exitRawRepl(),q}return Promise.reject(new Error("Path to file was not specified"))}async rmdir(G){if(G){let q="";q+="import os\n",q+="try:\n",q+=`  os.rmdir("${G}")\n`,q+="except OSError:\n",q+="  print(0)\n",await this.enterRawRepl();const J=await this.execRaw(q);return await this.exitRawRepl(),J}return Promise.reject(new Error("Path to file was not specified"))}async remove(G){if(G){let q="";q+="import os\n",q+="try:\n",q+=`  os.remove("${G}")\n`,q+="except OSError:\n",q+="  print(0)\n",await this.enterRawRepl();const J=await this.execRaw(q);return this.exitRawRepl()}return Promise.reject(new Error("Path to file was not specified"))}async rename(G,q){if(G&&q){await this.enterRawRepl();const J=await this.execRaw(`import os\nos.rename('${G}', '${q}')`);return this.exitRawRepl()}return Promise.reject(new Error("Path to file was not specified"))}async cat(G){if(G){await this.enterRawRepl();let q=await this.execRaw(`with open('${G}','r') as f:\n while 1:\n  b=f.read(256)\n  if not b:break\n  print(b,end='')`);return await this.exitRawRepl(),q=S(q),U(q)}return Promise.reject(new Error("Path to file was not specified"))}async put(G,q,J){if(J=J||function(){},G&&q){let O;if(typeof G==="string")O=this._encoder.encode(U(G));else if(G instanceof ArrayBuffer)O=new Uint8Array(G);else if(G instanceof Uint8Array)O=G;else Promise.reject(new Error(`${G} must string, Uint8Array or ArrayBuffer`));const Q=Array.from(O).map((W)=>W.toString(16).padStart(2,"0"));let V="";V+=await this.enterRawRepl(),V+=await this.execRaw(`f=open('${q}','w')\nw=f.write`);const X=48;for(let W=0;W<Q.length;W+=X){let w=`w(bytes([${Q.slice(W,W+X).map((H)=>`0x${H}`).join(",")}]))`;V+=await this.execRaw(w),J(parseInt(W/Q.length*100))}return V+=await this.execRaw("f.close()"),V+=await this.exitRawRepl(),J(100),V}return Promise.reject(new Error("Must specify content and destination path"))}}var F=(G,q,J)=>(G&248)<<8|(q&252)<<3|J>>3;function E(G,q){return new Promise((J)=>{const O=new Image;O.src=`data:${G};base64,${q}`,O.addEventListener("load",async()=>{const V=new OffscreenCanvas(O.width,O.height).getContext("2d",{willReadFrequently:!0});V.drawImage(O,0,0);const X=[];for(let W=0;W<O.height;W++)for(let Y=0;Y<O.width;Y++){const[K,w,H,k]=V.getImageData(Y,W,1,1).data,N=k===0?0:F(K,w,H);X.push(N>>8&255),X.push(N&255)}J(Uint8Array.from(X))})})}var D=async(G,q)=>{const J=new $;await J.requestPort(G),await J.connect(),await J.stop(),q(J);const O=()=>setTimeout(async()=>{if(J.connected)O();else q(null)},1000);return O(),J},x=async(G,q)=>{await G.disconnect(),q(null)},g=async(G,q,J)=>{await G.stop();const O=q.length;let Q=0;const V=(X)=>{J(parseInt((Q+1/O*(X/100))*100))};for(let X of q){let{id:W,content:Y}=X;if(X.type==="text/x-python")W+=".py";else if(X.type.startsWith("image/"))Y=await E(X.type,X.data);console.log(W),await G.put(Y,W,V),Q+=1/O}J(100),await G.reset()};export{g as downloadDevice,x as disconnectDevice,D as connectDevice,$ as MicroPythonBoard};
