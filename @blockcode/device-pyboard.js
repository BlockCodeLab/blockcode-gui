import{Serial as R,sleep as Y} from"@blockcode/core";var N=function(W){return W.replaceAll("\r\n","\n")},Z=function(W){return W.slice(2,-3)},y="\x01",K="\x02",z="\x03",M="\x04";var I=128;class X{constructor(){this.serial=null,this._connected=!1,this._encoder=new TextEncoder,this._decoder=new TextDecoder}requestPort(W=[]){return navigator.serial.requestPort({filters:W}).then((w)=>{if(w._serial){this.serial=w._serial,this.serial.on("connect",()=>this._connected=!0),this.serial.on("disconnect",()=>this._connected=!1);return}this.serial=new R(w),this.serial.on("connect",()=>this._connected=!0),this.serial.on("disconnect",()=>this._connected=!1)})}connect(W={}){return new Promise((w,$)=>{if(this.serial)this.serial.open({baudRate:115200,...W}).then(()=>w()).catch((q)=>{if(q.name==="InvalidStateError")this._connected=!0,w();$(q)});else $(new Error("No device specified"))})}get connected(){return this._connected}disconnect(){return this.serial.close()}get deviceInfo(){return this.serial.getInfo()}readUntil(W,w){return new Promise(($)=>{let q="";const G=async(J)=>{if(J){if(q+=this._decoder.decode(J),w)w(J)}if(q.indexOf(W)!==-1)this.serial.off("data",G),$(q)};this.serial.on("data",G)})}writeAndReadUntil(W,w,$){return new Promise(async(q)=>{if(w)this.readUntil(w,$).then(q);for(let G=0;G<W.length;G+=I)await this.serial.write(W.slice(G,G+I)),await Y(10);if(!w)q()})}async getPrompt(){return await Y(150),await this.stop(),await Y(150),await this.writeAndReadUntil(`\r${z}${K}`,"\r\n>>>")}async enterRawRepl(){return await this.writeAndReadUntil(y,"raw REPL; CTRL-B to exit")}async exitRawRepl(){return await this.writeAndReadUntil(K,"\r\n>>>")}async execRaw(W,w){return await this.writeAndReadUntil(W),await this.writeAndReadUntil(M,`${M}>`,w)}async execFile(W,w){if(w=w||function(){},W){await this.enterRawRepl();const $=await this.execRaw(W,w);return await this.exitRawRepl(),$}return Promise.reject()}async run(W,w){return w=w||function(){},new Promise(async($,q)=>{if(this.rejectRun)this.rejectRun(new Error("re-run")),this.rejectRun=null;this.rejectRun=q;try{await this.enterRawRepl();const G=await this.execRaw(W||"#",w);return await this.exitRawRepl(),$(G)}catch(G){q(G),this.rejectRun=null}})}async eval(W){await this.serial.write(W)}async stop(){if(this.rejectRun)this.rejectRun(new Error("pre stop")),this.rejectRun=null;await this.serial.write(z)}async reset(){if(this.rejectRun)this.rejectRun(new Error("pre reset")),this.rejectRun=null;await this.serial.write(z),await this.serial.write(M)}async exists(W){W=W||"";let w="";w+="try:\n",w+=`  f = open('${W}', 'r')\n`,w+="  print(1)\n",w+="except OSError:\n",w+="  print(0)\n",await this.enterRawRepl();const $=await this.execRaw(w);return await this.exitRawRepl(),$[2]=="1"}async listdir(W){W=W||"";let w="";w+="import os\n",w+="try:\n",w+=`  print(os.listdir('${W}'))\n`,w+="except OSError:\n",w+="  print([])\n",await this.enterRawRepl();let $=await this.execRaw(w);return await this.exitRawRepl(),$=Z($),$=$.replace(/'/g,'"'),JSON.parse($)}async mkdir(W){if(W){await this.enterRawRepl();const w=await this.execRaw(`import os\nos.mkdir('${W}')`);return await this.exitRawRepl(),w}return Promise.reject(new Error("Path to file was not specified"))}async rmdir(W){if(W){let w="";w+="import os\n",w+="try:\n",w+=`  os.rmdir("${W}")\n`,w+="except OSError:\n",w+="  print(0)\n",await this.enterRawRepl();const $=await this.execRaw(w);return await this.exitRawRepl(),$}return Promise.reject(new Error("Path to file was not specified"))}async remove(W){if(W){let w="";w+="import os\n",w+="try:\n",w+=`  os.remove("${W}")\n`,w+="except OSError:\n",w+="  print(0)\n",await this.enterRawRepl();const $=await this.execRaw(w);return this.exitRawRepl(),$}return Promise.reject(new Error("Path to file was not specified"))}async rename(W,w){if(W&&w){await this.enterRawRepl();const $=await this.execRaw(`import os\nos.rename('${W}', '${w}')`);return this.exitRawRepl(),$}return Promise.reject(new Error("Path to file was not specified"))}async cat(W){if(W){await this.enterRawRepl();let w=await this.execRaw(`with open('${W}','r') as f:\n while 1:\n  b=f.read(256)\n  if not b:break\n  print(b,end='')`);return await this.exitRawRepl(),w=Z(w),N(w)}return Promise.reject(new Error("Path to file was not specified"))}async checkHash(W,w){if(W){let $="";$+="import os\n",$+="import hashlib\n",$+="import binascii\n",$+="hash = hashlib.sha256()\n",$+=`with open('${W}', 'rb') as f:\n`,$+="  while True:\n",$+=`    c = f.read(${I})\n`,$+="    if not c: break\n",$+="    hash.update(c)\n",$+="print(binascii.hexlify(hash.digest()).decode())\n",await this.enterRawRepl();let q=await this.execRaw($);return await this.exitRawRepl(),q=q.slice(2,q.indexOf("\n")-1),w===q}return Promise.reject(new Error("Path to file was not specified"))}async put(W,w,$){if(!w){Promise.reject(new Error("Must specify content and destination path"));return}let q;if(typeof W==="string")q=this._encoder.encode(N(W));else if(W instanceof ArrayBuffer)q=new Uint8Array(W);else if(W instanceof Uint8Array)q=W;else Promise.reject(new Error(`${W} must string, Uint8Array or ArrayBuffer`));if($=$||function(){},await this.exists(w)){const O=await crypto.subtle.digest("SHA-256",q),V=Array.from(new Uint8Array(O)).map((H)=>H.toString(16).padStart(2,"0")).join("");if(await this.checkHash(w,V)){$(100);return}}const G=Array.from(q).map((O)=>O.toString(16).padStart(2,"0"));let J="";J+=await this.enterRawRepl(),J+=await this.execRaw(`f=open('${w}','w')\nw=f.write`);const Q=48;for(let O=0;O<G.length;O+=Q){let A=`w(bytes([${G.slice(O,O+Q).map((B)=>`0x${B}`).join(",")}]))`;J+=await this.execRaw(A),$(parseInt(O/G.length*100))}return J+=await this.execRaw("f.close()"),J+=await this.exitRawRepl(),$(100),J}}function E(W,w){const $=`data:${W};base64,${w}`;return fetch($).then((q)=>q.arrayBuffer())}var F=async(W,w)=>{const $=new X;await $.requestPort(W),await $.connect(),await $.stop(),w($);const q=()=>setTimeout(async()=>{if($.connected)q();else w(null)},1000);return q(),$},T=async(W,w)=>{await W.disconnect(),w(null)},x=async(W,w,$)=>{await W.stop();const q=w.length;let G=0;const J=(Q)=>{$(parseInt((G+1/q*(Q/100))*100))};for(let Q of w){let{id:O,content:V}=Q;if(Q.type==="text/x-python")O+=".py";else if(Q.type.startsWith("image/")&&!V)V=await E(Q.type,Q.data);await W.put(V||"",O,J),G+=1/q}$(100),await W.reset()};export{x as downloadDevice,T as disconnectDevice,F as connectDevice,X as MicroPythonBoard};
